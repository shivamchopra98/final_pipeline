import re
import copy
import logging
from typing import Dict, Any, List, Iterable, Optional
from utils.cve_utils import normalize_cve

log = logging.getLogger(__name__)

# regex to find all CVE IDs anywhere in text
_CVE_RE = re.compile(r"(CVE-\d{4}-\d{4,7})", re.IGNORECASE)

# Final schema for Packetstorm dataset
PACKETSTORM_FINAL_COLUMNS = [
    "cve_id",
    "packetstorm_advisories",
    "packetstorm_author",
    "packetstorm_description",
    "packetstorm_md5",
    "packetstorm_posted_date",
    "packetstorm_site",
    "packetstorm_systems",
    "packetstorm_tags",
    "packetstorm_title",
    "packetstorm_source",  # provenance marker
]

def clean_and_rename(record: Dict[str, Any]) -> Dict[str, Any]:
    """
    Compatibility wrapper — returns a single record for loader.
    If multiple CVEs are present, yields the first exploded record only.
    The rest will be handled in transform_batch().
    """
    exploded = explode_and_map_packetstorm(record)
    # Return only the first one for compatibility (loader expects dict)
    return exploded[0] if exploded else {}


def extract_cves_from_field(value: Any) -> List[str]:
    """Extract and normalize all CVE identifiers from a string value."""
    if value is None:
        return []
    s = str(value).strip()
    if not s or s.lower() == "null":
        return []
    matches = _CVE_RE.findall(s)
    normalized = []
    for m in matches:
        try:
            nm = normalize_cve(m) if m else None
        except Exception:
            nm = None
        if nm:
            nm = nm.upper()
            if nm not in normalized:
                normalized.append(nm)
    return normalized


def explode_and_map_packetstorm(record: Dict[str, Any]) -> List[Dict[str, Any]]:
    """
    Clean, rename, and explode Packetstorm dataset records by CVE.
    - Extracts multiple CVEs from a single record (creates one per CVE)
    - Applies field renaming to prefixed schema (packetstorm_*)
    - Normalizes CVE IDs
    - Fills missing values with None (→ DynamoDB NULL)
    """

    # Step 1️⃣ — Extract CVEs
    cve_value = record.get("CVE") or record.get("cve")
    cve_list = extract_cves_from_field(cve_value)
    if not cve_list:
        cve_list = [None]

    # Step 2️⃣ — Map original → prefixed schema
    rename_map = {
        "Advisories": "packetstorm_advisories",
        "Author": "packetstorm_author",
        "Description": "packetstorm_description",
        "MD5": "packetstorm_md5",
        "Posted Date": "packetstorm_posted_date",
        "Site": "packetstorm_site",
        "Systems": "packetstorm_systems",
        "Tags": "packetstorm_tags",
        "Title": "packetstorm_title",
    }

    # Step 3️⃣ — Build base mapped record (without CVE)
    base = {}
    for old, new in rename_map.items():
        val = record.get(old)
        if val is not None and str(val).strip().lower() != "null":
            base[new] = val
        else:
            base[new] = None

    # Add provenance marker
    base["packetstorm_source"] = "packetstorm"

    # Step 4️⃣ — Explode into one record per CVE
    exploded_records = []
    for cve in cve_list:
        row = copy.deepcopy(base)
        row["cve_id"] = normalize_cve(cve) if cve else None

        # Fill all missing final columns
        for col in PACKETSTORM_FINAL_COLUMNS:
            row.setdefault(col, None)

        exploded_records.append(row)

    return exploded_records


def transform_packetstorm_batch(records: Iterable[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Transform and explode a batch of Packetstorm records into a flattened, prefixed schema.
    Returns a clean list of rows with one CVE per record.
    """
    out = []
    for i, rec in enumerate(records):
        try:
            exploded = explode_and_map_packetstorm(rec)
            out.extend(exploded)
        except Exception as e:
            log.exception("Failed to process Packetstorm record index %s: %s", i, e)
    log.info("Packetstorm: input rows=%d -> exploded rows=%d", len(list(records)), len(out))
    return out


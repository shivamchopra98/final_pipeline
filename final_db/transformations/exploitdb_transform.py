# transformations/exploitdb_transform.py
"""
ExploitDB transformation (strict final schema with logging):
- Keeps only the final listed columns (no extras)
- Normalizes common source field names into final names
- Adds debug logs for renames and missing primary key
"""

import logging
from typing import Dict, Any, Optional

# ===========================================================
# üßæ Logging Setup
# ===========================================================
log = logging.getLogger(__name__)

# ===========================================================
# üéØ Final Schema Columns
# ===========================================================
EXPLOIT_FINAL_COLUMNS = [
    "exploit_id",
    "exploit_description",
    "exploit_file",
    "exploit_author",
    "exploit_type",
    "exploit_codes",
    "exploit_platform",
    "exploit_tags",
    "exploit_aliases",
    "screenshot_url",
    "application_url",
    "source_url",
]


# ===========================================================
# üß© Utility helper
# ===========================================================
def _get_field(record: Dict[str, Any], names) -> Optional[Any]:
    """Return the first matching field value from the record."""
    for n in names:
        if n in record:
            return record[n]
    return None


# ===========================================================
# üß± Transformation
# ===========================================================
def clean_and_rename(record: Dict[str, Any]) -> Dict[str, Any]:
    """
    Transform an ExploitDB record into the strict final schema.
    Only final columns are retained; unmapped source fields are ignored.
    """
    out: Dict[str, Any] = {}

    # Primary id
    eid = _get_field(record, ["id", "exploit_id", "exploitId", "ID"])
    if eid is not None:
        out["exploit_id"] = eid
    else:
        log.debug("‚ö†Ô∏è Missing exploit_id in ExploitDB record")

    # Map fields (check common variants)
    mapping = {
        "id": "exploit_id",
        "description": "exploit_description",
        "file": "exploit_file",
        "author": "exploit_author",
        "type": "exploit_type",
        "codes": "exploit_codes",
        "platform": "exploit_platform",
        "tags": "exploit_tags",
        "aliases": "exploit_aliases",
        "screenshot_url": "screenshot_url",
        "application_url": "application_url",
        "source_url": "source_url",

    }

    # Apply mapping and log
    for final_key, candidates in mapping.items():
        val = _get_field(record, candidates)
        if val is not None:
            out[final_key] = val
            log.debug(f"ü™∂ Mapped ExploitDB field {candidates} ‚Üí '{final_key}'")

    # Ensure final output contains exactly the final columns (values may be None)
    strict_output: Dict[str, Optional[Any]] = {k: out.get(k) for k in EXPLOIT_FINAL_COLUMNS}

    # Log summary
    if strict_output.get("exploit_id"):
        log.debug(f"‚úÖ Transformed ExploitDB record exploit_id={strict_output['exploit_id']}")
    else:
        log.debug("‚ö†Ô∏è Transformed ExploitDB record without exploit_id (will be skipped up-stream if required)")

    return strict_output
